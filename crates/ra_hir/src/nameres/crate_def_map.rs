/// This module implements new name-resolution/macro expansion algorithm.
///
/// The Result of this module is `CrateDefMap`: a datastructure which contains:
///
///   * a tree of modules for the crate
///   * for each module, a set of items visible in the module (directly declared
///     or imported)
///
/// Note that `CrateDefMap` contains fully macro expanded code.
///
/// To compute `CrateDefMap` we need to perform three somewhat different, but
/// intertwined, activities:
///
///   * recursive parsing of modules (macros can generate `mod foo;`
///     declarations, causing us to go and parse the file)
///   * name resolution for import and macro paths
///   * macro expansion
///
/// A "naive" algorithm to compute `CrateDefMap` would just do the above
/// activities repeatedly until there's nothing left to do.
///
/// Specifically, we start with the root module, parse it, add all imports to
/// the set of unresolved imports, add all macro calls to the set of unresolved
/// macro calls, add all non-module items to the set of visible items and
/// recursively parse all child module items. Then we resolve as much imports as
/// we can. Then we resolve anÐ² expand some macros (which might triger module
/// parsing). Then we resolve imports & macros again, and continue until no more
/// progress can be made.
///
/// Usig this algorithm won't be efficient in the IDE context: because we call
/// the parser directly, we'll have to re-execute everything on every change. To
/// make it more efficient, we need to introduce intermediate queries between
/// `CrateDefMap` and raw syntax. Roughtly speaking, typing inside the function
/// should not affect `CrateDefMap`, as it depends only on the top-level items &
/// macros. So
///
/// Specifically, we don't parse the file directly but ask for a set of
/// `RawItem`s, where `RawItem` is a position-independent representation of a
/// top-level item. Specifically, `RawItem` can be
///
///   * an import, represented by path
///   * a module, represented by name and either a path attribute or nested list
///     of `RawItem`s
///   * a macro, represented by path and the argument token-tree
///
/// Similarly, during macro expansion, we transform input token-tree to an
/// output token tree, parse it, and extract a set of `RawItem`s.
///
/// This approach allows us to reuse `CrateDefMap` after typing inside of an
/// item, but with one serious limitation. Because input token trees are a part
/// of `RawItem`s, typing inside an item decorated by macro does invalidate
/// stuff. This limitation can be partially fixed by storing a stable instead
/// the token tree itself. That is, we can introduce a query like
///
/// ```
/// expand_macro(
///     containing_file: FileId,
///     macro_id: u32, // the nth macro in a file.
///                    // Together with `FileId`, uniquely identifies
///                    // the source token treee,
///     macro_def: MacroDef,
/// ) -> Vec<RawItem>
/// ````
///
/// If after the change macro call expands to the same set of `RawItem` we don't
/// recompute anything.
///
/// The limitation of *this* fix is that it's only one level deep: we use
/// `FielId` to identifiy macro call, but macro calls inside files generated by
/// macro can't be identified by `FileId`! We can identify them by `Module`,
/// but, unfortunatelly, we can't refer to modules during construction of
/// `CrateDefMap`, because it's `CrateDefMap` that defines a module. In other
/// words, if we create a query `expand nth macro in X module`, it will depend
/// on `CrateDefMap` query, so using it from `CrateDefMap` will lead to cycle.

mod raw;
mod collector;

use rustc_hash::FxHashMap;
use ra_db::FileId;
use ra_arena::{Arena, impl_arena_id, RawId};
use ra_syntax::{AstNode, ast::{self, ModuleItemOwner}};

use crate::{Crate, PersistentHirDatabase, HirFileId, Name,
 module_tree::ModuleId,
 nameres::ModuleScope,
};

#[derive(Default)]
struct ModuleData {
    parent: Option<ModuleId>,
    children: FxHashMap<Name, ModuleId>,
    scope: ModuleScope,
}

/// Contans all top-level defs from a macro-expanded crate
#[derive(Default)]
pub(crate) struct CrateDefMap {
    modules: Arena<ModuleId, ModuleData>,
}
